package boj.impl.gold5.p2877;

import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		/**
		 *		 2, 2^2, 2^3, 2^4, ...
		 * 		 2, 2+2^2, ... , 2+2^2+...+2^n = 2^(n+1)-2
		 * 		 몇자리 수인지 범위
		 * 		 ex) k=60, 5 자리수로 판명 => 60 - 4자리합 = 60 - (2^5-2) = 60 - 30 = 30
		 * 		 30 - 3자리합 = 30 -(2^4-2) = 16
		 * 		 16 - 2자리합 = 16-(2^3-2) = 10
		 * 		 16 -
		 * 		 ex) k=10, 3자리수로 판명
		 * 		 10 - 2자리합 = 10 - (2^3-2) = 4  : 3자리수 중에 4번째거
		 * 		 4 - 1자리합 = 4-2 = 2
		 * 		 (4, 7) , (44, 47, 74, 77), (444, 447, 474, 477, ...)
		 *		10 > 2^(2+1) -2 => 3자리수
		 *		10 - 6 => 3자리수 중 4번째
		 *		4 / 4 = 1 => 2자리수 부분만 보면 1번 반복됨 : 2자리 수 중에 젤 마지막꺼!
		 * 		 k 최대 : 10억
		 * 		 2^(n+1) -2 <= 10억
		 * 		 n < 30
		 * 		 몇자린지 알아도.. n=29정도면 그 자리 내에서 완전탐색 안되지않나?
		 *		ex) k=12
		 *		12 < 2^(3+1)-2 , 12 > 2^(2+1)-2 => 3자리수
		 *		12 - 2^(2+1)-2 => 3자리수 중 6번째
		 *		6 / 2^2 = 1, 6 %(2^2) = 2 => 2자리수 부분 한번 반복 : 젤 앞자리=7이고 뒷부분은 2자리수 중 2번째거 : 7 +(47)
		 *		요약하면 자리수 구하고 (자리수-1) 경우부터 몫=1, 나머지 >0 => 앞자리 7붙이고 계속 나눠가면 될듯
		 *
		 */

		var scanner = new Scanner(System.in);
		long k = scanner.nextLong();

		long digits = 1;
		long digitValue = 2;
		while (digitValue < k) {
			digits++;
			digitValue += 2;
			digitValue *= 2;
			digitValue -= 2;
		}

		System.out.println(digits);

		var ans = "";
		for (; k > 0; k /= 2) {

		}
	}

}
